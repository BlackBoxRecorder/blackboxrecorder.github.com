<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BlackBoxRecorder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/github.min.css"
    />

    <link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css" />
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon" />

    <script>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement ("script");
        hm.src = "https://hm.baidu.com/hm.js?939e82af9dfa5085bf3cef376aa7fc50";
        var s = document.getElementsByTagName ("script")[0];
        s.parentNode.insertBefore (hm, s);
      })();
    </script>

    <style type="text/css">
      html,
      body {
        height: 100%;
      }

      html {
        scroll-behavior: smooth;
      }

      img {
        box-shadow: 5px 5px 5px 0px rgba (223, 219, 219, 0.75);
        /* 水平偏移 垂直偏移 模糊半径 颜色 */
        border-radius: 10px;
        /* 设置圆角半径 */
        border: 1px dashed black;
        /* 边框宽度 边框样式 边框颜色 */
      }
    </style>
  </head>

  <body class="bg-orange-100 h-full">
    <div class="h-full flex justify-center">
      <div class="w-3/5 h-full flex flex-col">
        <div class="flex pt-10">
          <h1 class="text-5xl font-bold">B.B.R Blog</h1>
          <p class="text-xl pt-5 pl-5"></p>
        </div>

        <div class="w-1/6 flex justify-between relative top-10 text-blue-600">
          <a href="/index.html"> 首页 </a>
          <a href="/archive.html"> 归档 </a>
          <a href="/about.html"> 关于 </a>
        </div>

        

<article class="markdown-body pt-20 grow">
  <h2 class="text-3xl font-bold">Unix 编程艺术 </h2>

  <div class="flex space-x-4">
    <span > 创建日期： 2023-09-21 </span>
    <span > 标签： <a href="/tags/ 计算机.html"> 计算机 </a> </span>
  </div>
  <hr />
  <div class=""><h2 > 引言 </h2>
<blockquote>
<p > 这是一本讲 Unix 编程的书，然而在这本书里，我们将反复提到 “文化”、“艺术” 以及 “哲学” 这些字眼。如果你不是程序员，或者对 Unix 涉水未深，这可能让你感觉很奇怪。但是 Unix 确实有它自己的文化；有独特的编程艺术；有一套影响深远的设计哲学。理解这些传统，会使你写出更好的软件，即使你是在非 Unix 平台上开发。</p>
</blockquote>
<blockquote>
<p > 性能 — 时间的指数曲线对软件开发过程所引发的结果，就是每过 18 个月，就有一半的知识会过时。Unix 并不承诺让你免遭此劫，只是让你的知识投资更趋稳定。因为不变的东西有很多：语言、系统调用、工具用法 —— 它们积年不变，甚至可以用上数十载。而在其它操作系统中则无法预判什么东西会持久不变，有时候甚至整个操作系统都会被淘汰。在 Unix 中，持久性知识和短期性知识有着明显的区别，人们在一开始学习的时候，就能提前判断（命中率约有九成）要学的知识属于哪一类。这些便是 Unix 有众多忠实拥趸的原因。</p>
</blockquote>
<blockquote>
<p > 策略相对短寿，而机制才会长存。</p>
</blockquote>
<blockquote>
<p>Unix 提供众多的程序粘合手段，这意味着 Unix 基本工具箱的各种组件连纵开合后，将收到单个工具设计者无法想象的功效。</p>
</blockquote>
<blockquote>
<p > 就算 Unix 在其它各个方面都一无是处，Unix 的工程文化仍然值得学习，它使得开发过程充满乐趣。乐趣是一个符号，意味着效能、效率和高产。</p>
</blockquote>
<blockquote>
<p>Unix 哲学说来不算是一种正规设计方法。它并不打算从计算机科学的理论高度来产生理论上完美的软件。那些毫无动力、松松垮垮而且薪水微薄的程序员们，能在短短期限内，如同神灵附体般造出稳定而新颖的软件 —— 这只不过是经理人永远的梦呓罢了。Unix 哲学（同其它工程领域的民间传统一样）是自下而上的，而不是自上而下的。Unix 哲学注重实效，立足于丰富的经验。你不会在正规方法学和标准中找到它，它更接近于隐性的半本能的知识，即 Unix 文化所传播的专业经验。它鼓励那种分清轻重缓急的感觉，以及怀疑一切的态度，并鼓励你以幽默达观的态度对待这些。</p>
</blockquote>
<blockquote>
<p>Unix 哲学是这样的：一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。</p>
</blockquote>
<p>Unix 哲学中更多的内容不是这些先哲们口头表述出来的，而是由他们所作的一切和 Unix 本身所作出的榜样体现出来的。从整体上来说，可以概括为以下几点：</p>
<ol>
<li><p > 模块原则：使用简洁的接口拼合简单的部件。</p>
</li>
<li><p > 清晰原则：清晰胜于机巧。</p>
</li>
<li><p > 组合原则：设计时考虑拼接组合。</p>
</li>
<li><p > 分离原则：策略同机制分离，接口同引擎分离。</p>
</li>
<li><p > 简洁原则：设计要简洁，复杂度能低则低。</p>
</li>
<li><p > 吝啬原则：除非确无它法，不要编写庞大的程序。</p>
</li>
<li><p > 透明性原则：设计要可见，以便审查和调试。</p>
</li>
<li><p > 健壮原则：健壮源于透明与简洁。</p>
</li>
<li><p > 表示原则：把知识叠入数据以求逻辑质朴而健壮。</p>
</li>
<li><p > 通俗原则：接口设计避免标新立异。</p>
</li>
<li><p > 缄默原则：如果一个程序没什么好说的，就沉默。</p>
</li>
<li><p > 补救原则：出现异常时，马上退出并给出足够错误信息。</p>
</li>
<li><p > 经济原则：宁花机器一分，不花程序员一秒。</p>
</li>
<li><p > 生成原则：避免手工 hack，尽量编写程序去生成程序。</p>
</li>
<li><p > 优化原则：雕琢前先要有原型，跑之前先学会走。</p>
</li>
<li><p > 多样原则：决不相信所谓 “不二法门” 的断言。</p>
</li>
<li><p > 扩展原则：设计着眼未来，未来总比预想来得快。</p>
</li>
</ol>
<h2 > 模块原则：使用简洁的接口拼合简单的部件 </h2>
<p > 正如 Brian Kernighan 曾经说过的：“计算机编程的本质就是控制复杂度”[Kernighan-Plauger]。排错占用了大部分的开发时间，弄出一个拿得出手的可用系统，通常与其说出自才华横溢的设计成果，还不如说是跌跌撞撞的结果。</p>
<p > 要编制复杂软件而又不至于一败涂地的唯一方法就是降低其整体复杂度 —— 用清晰的接口把若干简单的模块组合成一个复杂软件。如此一来，多数问题只会局限于某个局部，那么就还有希望对局部进行改进而不至牵动全身。</p>
<h2 > 清晰原则：清晰胜于机巧 </h2>
<p > 维护如此重要而成本如此高昂；在写程序时，要想到你不是写给执行代码的计算机看的，而是给人 —— 将来阅读维护源码的人，包括你自己 —— 看的。</p>
<p > 在 Unix 传统中，这个建议不仅意味着代码注释。良好的 Unix 实践同样信奉在选择算法和实现时就应该考虑到将来的可扩展性。而为了取得程序一丁点的性能提升就大幅度增加技术的复杂性和晦涩性，这个买卖做不得 —— 这不仅仅是因为复杂的代码容易滋生 bug，也因为它会使日后的阅读和维护工作更加艰难。</p>
<h2 > 组合原则：设计时考虑拼接组合 </h2>
<p > 如果程序彼此之间不能有效通信，那么软件就难免会陷入复杂度的泥淖。</p>
<p > 要想让程序具有组合性，就要使程序彼此独立。在文本流这一端的程序应该尽可能不要考虑文本流另一端的程序。将一端的程序替换为另一个截然不同的程序，而完全不惊扰另一端应该很容易做到。</p>
<h2 > 分离原则：策略同机制分离，接口同引擎分离 </h2>
<p > 把策略同机制揉成一团有两个负面影响：一来会使策略变得死板，难以适应用户需求的改变，二来也意味着任何策略的改变都极有可能动摇机制。相反，将两者剥离，就有可能在探索新策略的时候不足以打破机制。另外，我们也可以更容易为机制写出较好的测试（因为策略太短命，不值得花太多精力在这上面）。</p>
<p > 实现这种剥离的一个方法是，比如，将应用按照一个库来编写，这个库包含许多由内嵌脚本语言驱动的 C 服务程序，而至于整个应用的控制流程则用脚本来撰写而不是用 C 语言。这种模式的经典例子就是 Emacs 编辑器，它使用内嵌的脚本语言 Lisp 解释器来控制用 C 编写的编辑原语操作。我们会在第 11 章讨论这种设计风格。另一个方法是将应用程序分成可以协作的前端和后端进程，通过套接字上层的专用应用协议进行通讯；我们会在第 5 章和第 7 章讨论这种设计。前端实现策略，后端实现机制。比起仅用单个进程的整体实现方式来说，这种双端设计方式大大降低了整体复杂度，bug 有望减少，从而降低程序的寿命周期成本。</p>
<h2 > 简洁原则：设计要简洁，复杂度能低则低 </h2>
<p > 更为常见的是（至少在商业软件领域里），过度的复杂性往往来自于项目的要求，而这些要求常常基于当月的推销热点，而不是基于顾客的需求和软件实际能够提供的功能。许多优秀的设计被市场推销所需要的大堆大堆 “特性清单” 扼杀 —— 实际上，这些特性功能几乎从未用过。然后，恶性循环开始了：比别人花哨的方法就是把自己变得更花哨。很快，庞大臃肿变成了业界标准，每个人都在使用臃肿不堪、bug 极多的软件，连软件开发人员也不敢敝帚自珍。</p>
<h2 > 吝啬原则：除非确无它法，不要编写庞大的程序 </h2>
<p>“大” 有两重含义：体积大，复杂程度高。程序大了，维护起来就困难。由于人们对花费了大量精力才做出来的东西难以割舍，结果导致在庞大的程序中把投资浪费在注定要失败或者并非最佳的方案上。</p>
<h2 > 透明性原则：设计要可见，以便审查和调试 </h2>
<p > 因为调试通常会占用四分之三甚至更多的开发时间，所以一开始就多做点工作以减少日后调试的工作量会很划算。一个特别有效的减少调试工作量的方法就是设计时充分考虑透明性和显见性。软件系统的透明性是指你一眼就能够看出软件是在做什么以及怎样做的。显见性指程序带有监视和显示内部状态的功能，这样程序不仅能够运行良好，而且还可以看得出它以何种方式运行。设计时如果充分考虑到这些要求会给整个项目全过程都带来好处。至少，调试选项的设置应该尽量不要在事后，而应该在设计之初便考虑进去。这是考虑到程序不但应该能够展示其正确性，也应该能够把原开发者解决问题的思维模型告诉后来者。程序如果要展示其正确性，应该使用足够简单的输入输出格式，这样才能保证很容易地检验有效输入和正确输出之间的关系是否正确。出于充分考虑透明性和显见性的目的，还应该提倡接口简洁，以方便其它程序对其进行操作 —— 尤其是测试监视工具和调试脚本。</p>
<h2 > 健壮原则：健壮源于透明与简洁 </h2>
<p > 软件的健壮性指软件不仅能在正常情况下运行良好，而且在超出设计者设想的意外条件下也能够运行良好。大多数软件禁不起磕碰，毛病很多，就是因为过于复杂，很难通盘考虑。如果不能够正确理解一个程序的逻辑，就不能确信其是否正确，也就不能在出错的时候修复它。这也就带来了让程序健壮的方法，就是让程序的内部逻辑更易于理解。要做到这一点主要有两种方法：透明化和简洁化。</p>
<p > 在有异常输入的情况下，保证软件健壮性的一个相当重要的策略就是避免在代码中出现特例。bug 通常隐藏在处理特例的代码以及处理不同特殊情况的交互操作部分的代码中。</p>
<h2 > 表示原则：把知识叠入数据以求逻辑质朴而健壮 </h2>
<p > 数据要比编程逻辑更容易驾驭。所以接下来，如果要在复杂数据和复杂代码中选择一个，宁愿选择前者。更进一步：在设计中，你应该主动将代码的复杂度转移到数据之中去。</p>
<h2 > 通俗原则：接口设计避免标新立异 </h2>
<p > 最易用的程序就是用户需要学习新东西最少的程序 —— 或者，换句话说，最易用的程序就是最切合用户已有知识的程序。</p>
<h2 > 缄默原则：如果一个程序没什么好说的，就保持沉默 </h2>
<p > 我认为简洁是 Unix 程序的核心风格。一旦程序的输出成为另一个程序的输入，就很容易把需要的数据挑出来。</p>
<h2 > 补救原则：出现异常时，马上退出并给出足够错误信息。</h2>
<p > 软件要尽可能从容地应付各种错误输入和自身的运行错误。但是，如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止。</p>
<h2 > 经济原则：宁花机器一分，不花程序员一秒。</h2>
<p > 如果我们在整个软件开发中很严格的遵循这条原则的话，大多数的应用场合都应该使用高一级的语言。</p>
<h2 > 生成原则：避免手工 hack，尽量编写程序去生成程序 </h2>
<p > 在 Unix 传统中，人们大量使用代码生成器使易于出错的细节工作自动化。Parser/Lexer 生成器就是其中的经典例子，而 makefile 生成器和 GUI 界面式的构建器（interface builder）则是新一代的例子。</p>
<h2 > 优化原则：雕琢前先得有原型，跑之前先学会走 </h2>
<p > 过早优化是万恶之源。&quot;90% 的功能现在能实现，比 100% 的功能永远实现不了强 & quot;。做好原型设计可以帮助你避免为蝇头小利而投入过多的时间。
先制作原型，再精雕细琢。优化之前先确保能用。或者：先能走，再学跑。&quot; 极限编程 & quot; 宗师 Kent Beck 从另一种不同的文化将这一点有效地扩展为：先求运行，再求正确，最后求快。
先给你的设计做个未优化的、运行缓慢、很耗内存但是正确的实现，然后进行系统地调整，寻找那些可以通过牺牲最小的局部简洁性而获得较大性能提升的地方。
借助原型化找出哪些功能不必实现，有助于对性能进行优化；那些不用写的代码显然无需优化。目前，最强大的优化工具恐怕就是 delete 键了。我最有成效的一天就是扔掉了 1000 行代码。</p>
<h2 > 多样原则：决不相信所谓 & quot; 不二法门 & quot; 的断言。</h2>
<p > 对于软件设计和实现来说，Unix 传统有一点很好，即从不相信任何所谓的 & quot; 不二法门 & quot;。Unix 奉行的是广泛采用多种语言、开放的可扩展系统和用户定制机制。</p>
<h2 > 扩展原则：设计着眼未来，未来总比预想来得快。</h2>
<p > 设计代码时，要有很好的组织，让将来的开发者增加新功能时无需拆毁或重建整个架构。当然这个原则并不是说你能随意增加根本用不上的功能，而是建议在编写代码时要考虑到将来的需要，使以后增加功能比较容易。程序接合部要灵活， 在代码中加入 & quot; 如果你需要……&quot; 的注释。有义务给之后使用和维护自己编写的代码的人做点好事。
计算机编程的本质就是控制复杂度。</p>
<h2 > 应用 Unix 哲学 </h2>
<p > 这些富有哲理的原则决不是模糊笼统的泛泛之谈。在 Unix 世界中，这些原则都直接来自于实践，并形成了具体的规定，我们已经在上文中阐述了一些。以下列举的只是部分内容：</p>
<ul>
<li><p > 只要可行，一切都应该做成与来源和目标无关的过滤器。</p>
</li>
<li><p > 数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）。</p>
</li>
<li><p > 数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）。</p>
</li>
<li><p > 复杂的前端（用户界面）和后端应该泾渭分明。</p>
</li>
<li><p > 如果可能，用 C 编写前，先用解释性语言搭建原型。</p>
</li>
<li><p > 当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好。</p>
</li>
<li><p > 宽收严发（对接收的东西要包容，对输出的东西要严格）。</p>
</li>
<li><p > 过滤时，不需要丢弃的信息决不丢。</p>
</li>
<li><p > 小就是美。在确保完成任务的基础上，程序功能尽可能少。</p>
</li>
</ul>
<h2 > 态度也很重要 </h2>
<p > 看到该做的就去做 —— 短期来看似乎是多做了，但从长期来看，这才是最佳捷径。如果不能确定什么是对的，那么就只做最少量的工作，确保任务完成就行，至少直到明白什么是对的。要良好的运用 Unix 哲学，你就应该不断追求卓越。你必须相信，软件设计是一门技艺，值得你付出所有的智慧、创造力和激情。否则，你的视线就不会超越那些简单、老套的设计和实现；你就会在应该思考的时候急急忙忙跑去编程。你就会在该无情删繁就简的时候反而把问题复杂化 —— 然后你还会反过来奇怪你的代码怎么会那么臃肿、那么难以调试。</p>
<p > 要良好地运用 Unix 哲学，你应该珍惜你的时间决不浪费。一旦某人已经解决了某个问题，就直接拿来利用，不要让骄傲或偏见拽住你又去重做一遍。永远不要蛮干；要多用巧劲，省下力气到需要的时候再用，好钢用在刀刃上。善用工具，尽可能将一切都自动化。软件设计和实现应该是一门充满快乐的艺术，一种高水平的游戏。如果这种态度对你来说听起来有些荒谬，或者令你隐约感到有些困窘，那么请停下来，想一想，问问自己是不是已经把什么给遗忘了。如果只是为了赚钱或是打发时间，你为什么要搞软件设计而不是别的什么呢？你肯定曾经也认为软件设计值得你付出激情…… 要良好地运用 Unix 哲学，你需要具备（或者找回）这种态度。你需要用心。你需要去游戏。你需要乐于探索。</p>
</div>
</article>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
<script>
  hljs.highlightAll ();
</script>


        <div class="pt-10 h-30">
          <hr />
          <div class="pt-2 pb-3 h-18">BlackBoxRecorder @ 2023</div>
        </div>
      </div>
    </div>
  </body>
</html>
